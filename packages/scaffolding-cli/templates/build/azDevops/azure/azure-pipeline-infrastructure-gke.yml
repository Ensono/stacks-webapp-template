#############################################################################################################################
# This is a generated file which includes some replacements.                                                                #
# It is still very much recommended to go through this and ensure all variables are correct for your business/domain        #
# All variables are defined in a global scope.                                                                              #
# All Terraform produced resource names are using a labels module ensuring a predictable naming convention                  #
# E.g.: variables for company, project, stage and component will produce a name of `$company-$project-$stage-$componenet`   #
# NB: Some resources e.g. blob storage only allow for alpha numeric characters so the name is adjusted accordingly          #
#  ==> `$company$project$stage$componenet`                                                                                  #
#############################################################################################################################
name: '$(build.sourcebranchname)-init'

pr: none
trigger:
  branches:
    include:
    - '*'
  paths:
    include:
    - 'packages/scaffolding-cli/templates/build/*'
    - 'packages/scaffolding-cli/templates/deploy/gcp/*'

resources:
  repositories:
  - repository: templates
    type: github
    name: amido/stacks-pipeline-templates
    ref: feature/cycle2
    endpoint: amidostacks
  containers:
  - container: k8s_deploy
    image: amidostacks/ci-k8s:0.0.5
  - container: terraform_custom
    image: amidostacks/ci-tf:0.0.3

variables:
  company: amido
  project: stacks
  domain: gke-infra
  component: infra
  # Versioning
  version_major: 0
  version_minor: 0
  version_revision: $[counter(variables['version_minor'], 0)]
  # SelfConfig
  self_repo: stacks-webapp-template/packages/scaffolding-cli/templates
  self_repo_tf_src: deploy/gcp/infra/stacks-gke
  # TF STATE CONFIG
  tf_state_rg: amido-stacks-rg-uks
  tf_state_storage: amidostackstfstategbl
  tf_state_container: tfstate
  # Stacks operates Terraform states based on workspaces **IT IS VERY IMPORTANT** that you ensure a unique name for each application definition
  # Furthermore **IT IS VERY IMPORTANT** that you change the name of a workspace for each deployment stage
  # there are some best practices around this if you are going for feature based environments
  # - we suggest you create a runtime variable that is dynamically set based on a branch currently running
  # **`terraform_state_workspace: `** all states will be saved under this key for this definition
  # avoid running anything past dev that is not on master
  # sample value: sharedservices
  tf_state_key: gke-infra
  # Docker Config
  # SEE OUTPUTTED VALUE from Infra Bootstrap stage
  # AKS/AZURE
  # This will always be predictably named by setting your company - project - stage - location - compnonent names above
  # IT IS SET per stage as an output to be consumed by deploy stage
  gke_cluster_version: "1.15.11-gke.12"
  gcp_region: europe-west2
  gcp_project_name: amido-stacks
  # DEFAULT IMAGE RUNNER
  pool_vm_image: ubuntu-18.04
  deployed_base_url: https://stacks-webapp.com/foo
  # Ensure you find this definition in the K8s and Azure steps to prefix with desired subdomain assignment
  base_domain: gke.nonprod.amidostacks.com

stages:
- stage: nonprod
  variables:
  # You can find notes in the READMEs around which values to use for each ENV variable group 
  - group: amido-stacks-infra-credentials-nonprod
  jobs:
  - job: InfraNonProd
    variables:
      foo: bar 
    pool:
      vmImage: ubuntu-18.04
    container: terraform_custom
    steps:
      - checkout: self
      - checkout: templates
        persistCredentials: true
        env:
          ARM_SUBSCRIPTION_ID: $(azure_subscription_id)
          ARM_CLIENT_ID: $(azure_client_id)
          ARM_CLIENT_SECRET: $(azure_client_secret)
          ARM_TENANT_ID: $(azure_tenant_id)
          GOOGLE_CREDENTIALS: $(GOOGLE_CREDENTIALS)
        # target: terraform_custom
        target:
          container: terraform_custom
      # Create TF infra
      - template: azDevOps/azure/templates/v2/steps/deploy-terraform-meta-generic.yml@templates
        parameters: 
          # Terraform Basic Config
          working_dir: '$(Agent.BuildDirectory)/s/$(self_repo)/$(self_repo_tf_src)'
          # changing this would require changing the downstream consumers of these outputs
          # 
          terraform_output_artefact: 'tfoutputs'
          #Auth config
          terraform_auth_properties: {
            ARM_CLIENT_ID: $(azure_client_id),
            ARM_CLIENT_SECRET: $(azure_client_secret),
            ARM_SUBSCRIPTION_ID: $(azure_subscription_id),
            ARM_TENANT_ID: $(azure_tenant_id),
            GOOGLE_CREDENTIALS: $(GOOGLE_CREDENTIALS)
          }
          # Terraform State Config
          terraform_init_backend_config: '-backend-config="key=$(tf_state_key)" -backend-config="storage_account_name=$(tf_state_storage)" -backend-config="resource_group_name=$(tf_state_rg)" -backend-config="container_name=$(tf_state_container)"'
          terraform_state_workspace: nonprod
          # Global Config
          # Azure config
          tags: ''
          # Terraform Resource Specific Config
          terraform_extra_properties: {
            TF_VAR_project: $(GCP_PROJECT),
            TF_VAR_location: $(gcp_region),
            TF_VAR_region: $(gcp_region),
            TF_VAR_name_company: $(company),
            TF_VAR_name_project: $(project),
            TF_VAR_name_component: $(domain),
            TF_VAR_name_environment: nonprod,
            TF_VAR_cluster_version: $(gke_cluster_version),
            TF_VAR_stage: nonprod,
            TF_VAR_dns_zone: $(base_domain)
          }
          terraform_output_commands: |
            raw_tf=$(terraform output -json | jq -r 'keys[] as $k | "##vso[task.setvariable variable=\($k);isOutput=true]\(.[$k] | .value)"')
            readarray -t outputs <<<"$raw_tf"
            for i in "${outputs[@]}"; do echo "$i"; done

  - job: K8sNonProd
    dependsOn: InfraNonProd
    variables:
      ingress_public_ip: $[ dependencies.InfraNonProd.outputs['tfoutputs.gke_ingress_public_ip'] ]
      cluster_name: $[ dependencies.InfraNonProd.outputs['tfoutputs.cluster_name'] ]
      project_id: $[ dependencies.InfraNonProd.outputs['tfoutputs.project_id'] ]
      region: $[ dependencies.InfraNonProd.outputs['tfoutputs.region'] ]
      # if you have extended the infra definition and assigned output variables you can specify them here
    pool:
      vmImage: ubuntu-18.04
    container: k8s_deploy
    steps:
      - checkout: self
      - checkout: templates
        persistCredentials: true
        env:
          GOOGLE_CREDENTIALS: $(GOOGLE_CREDENTIALS)
        target: k8s_deploy

      # ensure scripts are executable
      - template: azDevOps/azure/templates/v2/steps/aux-k8s-scripts.yml@templates
        parameters:
          scripts_dir: $(Agent.BuildDirectory)/s/stacks-pipeline-templates/azDevOps/azure/templates/v2

      #####
      # Sample left for base K8s cluster bootstrap
      #####
      - template: azDevOps/azure/templates/v2/steps/yaml-k8s-templater.yml@templates
        parameters: 
          scripts_dir: $(Agent.BuildDirectory)/s/stacks-pipeline-templates/azDevOps/azure/templates/v2/scripts
          template_input: [
           {
              base: $(Agent.BuildDirectory)/s/$(self_repo)/build/azDevops/azure/k8s_manifests/base_gke-nginx-ingress.yml, 
              out: $(Agent.BuildDirectory)/s/$(self_repo)/build/azDevops/azure/k8s_manifests/nginx-ingress.yml, 
              displayName: NginxIngress,
              env_vars: {
                ingress_public_ip: $(ingress_public_ip)
              }
            }
          ]

      - template: azDevOps/azure/templates/v2/steps/deploy-gke-cluster.yml@templates
        parameters: 
          scripts_dir: $(Agent.BuildDirectory)/s/stacks-pipeline-templates/azDevOps/azure/templates/v2/
          gcp_auth: {
            CLOUDSDK_COMPUTE_REGION: $(region),
            CLOUDSDK_CONTAINER_CLUSTER: $(cluster_name),
            CLOUDSDK_CORE_PROJECT: $(project_id)
          }
          # ONLY USED FOR kubectl apply
          cluster_name: $(cluster_name)
          ingress_definition:
            # TODO: make this a complex object so that additional args can be passed in
            # https://kubernetes.github.io/ingress-nginx/deploy/#gce-gke
            - $(Agent.BuildDirectory)/s/$(self_repo)/build/azDevops/azure/k8s_manifests/nginx-ingress.yml
